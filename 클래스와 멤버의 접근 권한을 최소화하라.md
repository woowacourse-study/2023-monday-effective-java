## 잘 설계된 컴포넌트?
👉 독립적인 컴포넌트

## 독립적이면 뭐가 좋을까?
- 다른 컴포넌트와 병렬적으로 개발할 수 있다.
- 더 작은 기능 단위로 테스트 해볼 수 있다.
- 소프트웨어 재사용성을 높일 수 있다.
- 컴포넌트의 변경에 외부에서 받는 영향이 적어진다.

## 컴포넌트를 독립적으로 만드는 방법
👉 인터페이스만을 제공하고 내부 구현을 숨겨야 한다. 이를 정보 은닉이라고 부른다.
> 즉, 외부에 정보를 최소한으로만 제공해야 한다. 
> 자바에서는 접근제어자를 통해 권한을 최소화할 수 있다.

## 클래스와 인터페이스
👉 public과 package-private만 사용 가능
- public: 공개 api가 된다. 만약 버전이 변하더라도 하위 호환을 위해 계속 지원해줘야 한다.
- package-private: 패키지에서만 사용할 수 있는 클래스가 된다. 공개되지 않기 때문에 수정, 삭제 등이 자유롭다. 
- 중첩된 private static: 이 클래스가 포함된 외부 클래스에서만 사용할 수 있다. 만일 한 클래스에서만 사용한다면 고려해보자.

## 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)
![img.png](img.png)

### 필드가 열려있는 경우
```
// client
public void move() {
    cars.forEach(car -> car.x += 1);
}

// server
package com.server.car

public class Car {
    public int x;
}
```
👉 만약 x의 네이밍을 리팩토링하고 싶다면??

👉 만약 로직이 바껴서 x를 제거하고 싶다면??

👉 객체의 상태에 대한 책임도 더 이상 Car에 있지 않다.

### 객체의 참조를 그대로 반환하는 경우

```
// client
Cars cars = Cars.of(List.of(new Car("에밀"), new Car("오리"), new Car("모디"), new Car("에단"), new Car("디투"), new Car("홍실")));
raceResult = race(cars);

public RaceResult race(Cars cars) {
    List<Car> carList = cars.getCars();
    for (int i = 0; i < carList.size(); i++) {
        carList.get(i).move();
    }
    ...
    return raceResult;
}

// server
public class Cars {
    private List<Car> cars;
    
    public static Cars of(List<String> names) {
        ...
    }
    
    public List<Car> getCars() {
        return cars;
    }
}

결과
에밀: 10 -> +5점
나머지: 0 -> +0점
```

👉 더 이상 List<Car>의 제어권은 Cars에 있지 않다.

👉 만약 라운드제 게임으로 변경된다면?

```
2라운드 레이스
raceResult = race(cars);
...

결과
에밀: 11 -> +5점
나머지: 2 -> +0점

버그 발생
???
```
👉 객체의 참조를 그대로 반환하면 내부의 상태 제어가 객체의 책임 밖으로 벗어난다.

👉 하나의 메서드로 추상화했다면 클라이언트 코드의 변경 없이 내부 메서드로 변경이 가능하다.

```
// 변경전

// client
cars.race();

// server
public RaceResult race() {
    cars.forEach(car -> car.move())
    return raceResult;
}

// 변경 후

// client
cars.race();

// server
public RaceResult race() {
    cars.forEach(car -> car.move())
    RaceResult raceResult = ...;
    cars.forEach(car -> initialize())
    return raceResult;
}

```

### 테스트를 위해 멤버를 protected로 변경하게 된다면..?

```
// production
public class LadderGenerator {
    public Ladder generate() {
        ...
    }
    
    protected Row generateRow() {
        ...
    }
}

// test
class LadderGeneratorTest extends LadderGenerator {
    @Test
    void generateRowTest() {
        assertThat(ladder.generateRow()).isEqualTo(...);
    }
}
```
👉 테스트를 위해 protected로 접근 제어자를 변경하게 되면
- protected의 의도를 알아차리기 힘들어 가독성이 떨어진다.
- 다른 패키지에서 이 코드를 사용하는 한 계속해서 해당 멤버를 지원해야 한다. 
- 상속을 유발하게 되어 프로그램 구조를 경직되게 만들 수 있다.